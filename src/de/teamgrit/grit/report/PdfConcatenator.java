/*
 * Copyright (C) 2014 Team GRIT
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package de.teamgrit.grit.report;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.output.FileWriterWithEncoding;

import de.teamgrit.grit.preprocess.Student;

/**
 * The PdfConcatinator is an utility class to merge the pdfs generated by the
 * {@link TexGenerator} .
 *
 * @author <a href="mailto:gabriel.einsdorf@uni-konstanz.de">Gabriel
 *         Einsdorf</a>
 */

public class PdfConcatenator {

    private static final Logger LOGGER = Logger.getLogger("systemlog");

    private PdfConcatenator(){
        // prevent instantiation
    }

    /**
     * Concatinates pdfs generated {@link TexGenerator}.
     *
     * @param folderWithPdfs
     *            the folder with pdfs
     * @param outPath
     *            the out path
     * @param exerciseName
     *            the context
     * @param studentsWithoutSubmissions
     *            list of students who did not submit any solution
     * @return the path to the created PDF
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    protected static Path concatPDFS(
            Path folderWithPdfs, Path outPath, String exerciseName,
            List<Student> studentsWithoutSubmissions, String filename) throws IOException {
      LOGGER.info("Concatenating pdfs for exercise \""
            +exerciseName+"\" in "+folderWithPdfs.toString());
      if ((folderWithPdfs == null) || !Files.isDirectory(folderWithPdfs)) {
        throw new IOException("The Path doesn't point to a Folder");
      }

      File file = new File(outPath.toFile(), filename);

      if (Files.exists(file.toPath(), LinkOption.NOFOLLOW_LINKS)) {
        Files.delete(file.toPath());
      }
      file.createNewFile();

      writePreamble(file, exerciseName);
      writeMissingStudents(file, studentsWithoutSubmissions);
      writeUncompilableTexDocuments(file, folderWithPdfs);
      writeFiles(file, folderWithPdfs);
      writeClosing(file);

      PdfCreator.createPdfFromPath(file.toPath(), outPath);
      LOGGER.fine(
          "Report creation for exercise \""+exerciseName+"\" finished");

      return file.toPath();

    }

    /**
     * Writes the preamble and title to the file.
     *
     * @param file
     *            the file
     * @param exerciseName
     *            the name of the exercise
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private static void writePreamble(File file, String exerciseName)
            throws IOException {
        FileWriterWithEncoding writer =
                new FileWriterWithEncoding(file, "UTF-8", true);

        LOGGER.fine("Writing report preamble for " + exerciseName);
        writer.append("\\documentclass[a4paper,10pt,ngerman]{scrartcl} \n");
        writer.append("\\usepackage[ngerman]{babel}\n");
        writer.append("\\usepackage[utf8]{inputenc}");
        writer.append("\\usepackage{pdfpages} \n");
        writer.append("\\usepackage{grffile} \n");
        writer.append("\\begin{document} \n");
        writer.append("\\begin{titlepage}\n");
        writer.append("\\begin{center}\n");
        writer.append("\\textsc{\\LARGE Universit\"at Konstanz}\\\\[1.5cm]\n\n");
        writer.append("{\\large Korrektur\n\n");
        writer.append("\\rule{\\linewidth}{0.5mm}\\\\[0.4cm]\n");
        writer.append("{\\fontfamily{qhv}\\huge\\bfseries \\texttt{\\detokenize{")
                       .append(exerciseName).append("}}").append(" \\\\[0.4cm]}\n\n");
        writer.append("\\rule{\\linewidth}{0.5mm}\\\\[0.5cm]\n\n");
        writer.append("\\vfill\n");
        writer.append("{\\large\\today\n");
        writer.append("\\end{center}\n");
        writer.append("\\end{titlepage}\n");

        writer.close();
        LOGGER.fine("Writting preamble finished successfully");
    }

    /**
     * Write the pdfs to the file.
     *
     * @param outFile
     *            the out file
     * @param folderWithPdfs
     *            the folder with pdfs
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private static void writeFiles(File outFile, Path folderWithPdfs)
            throws IOException {

        FileWriterWithEncoding writer =
                new FileWriterWithEncoding(outFile, "UTF-8", true);

        File[] files = folderWithPdfs.toFile().listFiles();
        LOGGER.info("Appending pdfs to final report for "
            +outFile.getName()+" in "+folderWithPdfs.toString());
        if(files.length > 0){
          for (File file : files) {
            LOGGER.finer("Processing pdf: "+file.getName());

            // We only want the the PDFs as input
            if ("pdf".equals(FilenameUtils.getExtension(file.getName()))) {
                writer.append("\\includepdf[pages={1-}]{")
                        .append(file.getAbsolutePath()).append("} \n");
                LOGGER.finest("Appending: "+file.getName());
                }
          }
        } else {
            LOGGER.warning("No Reports available in the specified folder: " + folderWithPdfs.toString());
        }
        writer.close();
        LOGGER.fine("Appending pdfs finished");
    }

    /**
     * Writes the closing part of the file.
     *
     * @param file
     *            the file
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private static void writeClosing(File file) throws IOException {
        FileWriterWithEncoding writer =
                new FileWriterWithEncoding(file, "UTF-8", true);
        LOGGER.fine("Writing closing");

        writer.append("\\label{lastpage}");
        writer.append("\\end{document}\n");

        writer.close();
        LOGGER.finer("Writing closing finished.");
    }

    /**
     * Writes the names of the students who didn't hand in a submission
     * into the report.
     * 
     * In case one or more missing submissions are found a separate page
     * is being created and the acronyms of the students, whose submission
     * is missing, is appended.
     * 
     * They are listed utilizing LaTeX minipages, dividing the list into
     * two halves and processing each of them sequentially.
     * 
     * @param file
     *            the file that gets written into.
     * @param studentWithoutSubmissions
     *            a list with students who did not submit any solution.
     * @throws IOException
     *             If something goes wrong when writing.
     */
    private static void writeMissingStudents(
            File file, List<Student> studentWithoutSubmissions)
            throws IOException {

        // // the list of students who didn't hand in a submission
        // List<Student> missing = context.getPreprocessor()
        // .getStudentsWithoutSubmission();

        // only write if there are any missing submissions
        LOGGER.info("Checking for missing submissions");
        if (!(studentWithoutSubmissions == null)
                && !(studentWithoutSubmissions.isEmpty())) {
            LOGGER.fine("Missing submissions found. Processing.");

            FileWriterWithEncoding writer =
                    new FileWriterWithEncoding(file, "UTF-8", true);

            writer.append("{\\LARGE\\bf Studenten welche nicht abgegeben haben:}\\\\\n\\\\");
            writer.append("\\begin{minipage}{.5\\textwidth}\n");
            writer.append("\\begin{itemize}\n");
            for (int i = 0; i < studentWithoutSubmissions.size(); i += 2) {
                writer.append("\\item ")
                        .append(studentWithoutSubmissions.get(i).getName())
                        .append("\n");
                LOGGER.finest("Appending: "+studentWithoutSubmissions.get(i).getName());
            }
            writer.append("\\end{itemize}\n");
            writer.append("\\end{minipage}");
            
            LOGGER.finer("Wrote first half of missing submissions to file.");

            writer.append("\\begin{minipage}{.5\\textwidth}\\raggedright\n");
            writer.append("\\begin{itemize}\n");
            if (studentWithoutSubmissions.size() > 1) {
              for (int i = 1; i < studentWithoutSubmissions.size(); i += 2) {
                writer.append("\\item ")
                        .append(studentWithoutSubmissions.get(i).getName())
                        .append("\n");
                LOGGER.finest("Appending: "+studentWithoutSubmissions.get(i).getName());
              }
            } else {
              // to prevent empty right handside minipages,
              // add one extra "hidden" item
              writer.append("\\item[] ");
            }
            writer.append("\\end{itemize}\n");
            writer.append(
                "\\end{minipage}\n\\\\");
            writer.close();
        }
        LOGGER.fine("Processing missing submissions finished");
    }

    /**
     * This method appends the filenames of non-compiled .tex files 
     * to the given report. This section is only added in case a 
     * non-compiling submission-report for a student has been found. 
     * Otherwise this section is omitted.
     * <br></br>
     * The check for compilability is done by checking whether 
     * the corresponding pdf to each .tex file exists.
     * 
     * @param outFile The file to append the results to
     * @param folderWithPdfs The folder whose content is being checked
     * @throws IOException in case any I/O errors occur
     */
    private static void writeUncompilableTexDocuments(
        File outFile, Path folderWithPdfs) throws IOException {

      File[] files = folderWithPdfs.toFile().listFiles();

      LOGGER.info("Check for uncompilable .tex-files started");
      List<File> nonCompilingFiles = new ArrayList<>();
      for (File file : files) {
        if ("tex".equals(FilenameUtils.getExtension(file.getName()))) {
          LOGGER.fine("Processing: "+file.getName());
          File correspondingPDF = new File(
            file.getParent()+"/"+file.getName().split("(\\.tex)")[0]+".pdf");
          if (!correspondingPDF.exists()) {
            nonCompilingFiles.add(file);
            LOGGER.finest(
              "Appending "+file.getName()+" to uncompilable .tex-files.");
          }
        }
      }
      if (nonCompilingFiles.size() > 0) {

        FileWriterWithEncoding writer =
            new FileWriterWithEncoding(outFile, "UTF-8", true);

        LOGGER.fine("Uncompilable .tex-Files found! Starting report.");

        writer.append(
              "\\medskip\\\\\\n"
            + "{\\LARGE\\bf Tex-Files welche nicht kompilierten:}\\\\\n\\\\");
        writer.append("\\begin{minipage}{.5\\textwidth}\n");
        writer.append("\\begin{itemize}\n");
        for (int i = 0; i < nonCompilingFiles.size(); i += 2) {
          writer.append("\\item ")
                  .append(nonCompilingFiles.get(i).getName())
                  .append("\n");
          LOGGER.finest("Appending: "+nonCompilingFiles.get(i).getName());
        }
      writer.append("\\end{itemize}\n");
      writer.append("\\end{minipage}");

      LOGGER.finer("Wrote first half of non-compiling .tex files.");

      writer.append("\\begin{minipage}{.5\\textwidth}\\raggedright\n");
      writer.append("\\begin{itemize}\n");
      if (nonCompilingFiles.size() > 1) {
        for (int i = 1; i < nonCompilingFiles.size(); i += 2) {
          writer.append("\\item ")
                  .append(nonCompilingFiles.get(i).getName())
                  .append("\n");
          LOGGER.finest("Appending: "+nonCompilingFiles.get(i).getName());
        }
      } else {
        // to prevent empty right handside minipages,
        // add one extra "hidden" item
        writer.append("\\item[] ");        
      }
      writer.append("\\end{itemize}\n");
      writer.append("\\end{minipage}\n");
      writer.close();
      }
      LOGGER.fine("Processing uncompilable .tex files finished");
    }
}
